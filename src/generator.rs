use bc_rand::{ rng_random_data, RandomNumberGenerator };
use dcbor::{ CBOREncodable, Date };
use serde::{ Serialize, Deserialize };
use crate::util::{ serialize_base64, deserialize_base64 };

use crate::{
    crypto_utils::extend_key,
    xoshiro256starstar::Xoshiro256StarStar,
    ProvenanceMark,
    ProvenanceMarkResolution,
};

const PROVENANCE_SEED_LENGTH: usize = 32;
pub type ProvenanceSeed = [u8; PROVENANCE_SEED_LENGTH];
pub type ProvenanceRngState = [u8; PROVENANCE_SEED_LENGTH];

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct ProvenanceMarkGenerator {
    res: ProvenanceMarkResolution,
    #[serde(serialize_with = "serialize_base64", deserialize_with = "deserialize_base64")]
    seed: Vec<u8>,
    #[serde(rename = "chainID")]
    #[serde(serialize_with = "serialize_base64", deserialize_with = "deserialize_base64")]
    chain_id: Vec<u8>,
    #[serde(rename = "nextSeq")]
    next_seq: u32,
    #[serde(rename = "rngState")]
    #[serde(serialize_with = "serialize_base64", deserialize_with = "deserialize_base64")]
    rng_state: Vec<u8>,
}

impl ProvenanceMarkGenerator {
    pub fn new(
        res: ProvenanceMarkResolution,
        seed: ProvenanceSeed,
        chain_id: Vec<u8>,
        next_seq: u32,
        rng_state: ProvenanceRngState
    ) -> Self {
        assert!(chain_id.len() == res.link_length());
        Self { res, seed: seed.to_vec(), chain_id, next_seq, rng_state: rng_state.to_vec() }
    }

    pub fn from_seed(res: ProvenanceMarkResolution, seed: ProvenanceSeed) -> Self {
        let chain_id = seed[..res.link_length()].to_vec();
        Self::new(res, seed, chain_id, 0, seed)
    }

    pub fn new_using<R>(
        res: ProvenanceMarkResolution,
        rng: &mut impl RandomNumberGenerator
    ) -> Self {
        // Randomness for a new seed can come from any secure random number generator.
        let data = rng_random_data(rng, PROVENANCE_SEED_LENGTH);
        let mut seed = [0; PROVENANCE_SEED_LENGTH];
        seed.copy_from_slice(&data);
        Self::from_seed(res, seed)
    }

    pub fn from_passphrase(res: ProvenanceMarkResolution, passphrase: &str) -> Self {
        let seed = extend_key(passphrase.as_bytes());
        Self::from_seed(res, seed)
    }

    pub fn next(&mut self, date: Date, info: Option<impl CBOREncodable>) -> ProvenanceMark {
        let data: [u8; 32] = self.rng_state.as_slice().try_into().unwrap();
        let mut rng = Xoshiro256StarStar::from_data(&data);

        let seq = self.next_seq;
        self.next_seq += 1;

        let key;
        if seq == 0 {
            key = self.chain_id.clone();
        } else {
            // The randomness generated by the PRNG should be portable across implementations.
            key = rng.next_bytes(self.res.link_length());
            self.rng_state = rng.to_data().to_vec();
        }

        let mut next_rng = rng.clone();
        let next_key = next_rng.next_bytes(self.res.link_length());

        ProvenanceMark::new(
            self.res,
            key,
            next_key,
            self.chain_id.clone(),
            seq,
            date,
            info
        ).unwrap()
    }
}

impl std::fmt::Display for ProvenanceMarkGenerator {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(
            f,
            "ProvenanceMarkGenerator(chainID: {}, res: {}, seed: {}, nextSeq: {}, rngState: {:?})",
            hex::encode(&self.chain_id),
            self.res,
            hex::encode(&self.seed),
            self.next_seq,
            self.rng_state
        )
    }
}
